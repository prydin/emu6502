        .ORG    $2000

        ; Physics constants
GRAVITY .EQ     32      ; 1/8 pixels/frame^2
BOUNCE  .EQ     240     ; 15/16 of kinetic energy preserved in bounce

VIC     .EQ     $D000
SPTRS   .EQ     $07f8

        ; Initialize sprites
        LDA     #((>SPRITE << 8) + <SPRITE) >> 6    ; Load address of sprite 1 data
        STA     SPTRS
        LDA     #100
        STA     VIC
        STA     VIC+$01
        LDA     VIC+$15
        AND     #$01
        LDA     #$01
        STA     VIC+$25
        STA     VIC+$15

        ; Initialize interrupts
        SEI                 ; Disable IRQ
        LDA     #$30
        STA     VIC+$12
        LDA     VIC+$1A     ; Enable raster IRQ
        ORA     #$01
        STA     VIC+$1A
        LDA     #<FRAME
        STA     $0314
        LDA     #>FRAME
        STA     $0315
        CLI                 ; Enable IRQ
        RTS

        ; Raster IRQ - New frame
FRAME   BIT     VIC+$19     ; Is it for us?
        BMI     DOIRQ
        JMP     $EA31       ; Not for us, give control back to kernal

DOIRQ   STA     ASAVE       ; Save registers
        STX     XSAVE
        STY     YSAVE

        ; Physics calculations
        ; Handle vertical bounce
        LDA     VY0+1       ; Bounce on downward motion only
        AND     #$80
        BNE     HBOUNCE
        LDA     Y0+1        ; Check if we've passed the lower bound
        CMP     #230
        BCC     HBOUNCE

        ; Calculate lost momentum in bounce. 1/8 of the momentum is lost in each bounce
        ; This can be expressed as:
        ; v * 7/8 = x - (v/8) = v - (v >> 3)
        LDA     VY0
        STA     TEMP1
        LDA     VY0+1
        STA     TEMP2
        CMP     #$80        ; Sign extend (Original MSB negative -> carry set)
        ROR     TEMP2       ; 1
        ROR     TEMP1
        CMP     #$80
        ROR     TEMP2       ; 2
        ROR     TEMP1
        CMP     #$80
        ROR     TEMP2       ; 3
        ROR     TEMP1

        ; TEMP2 and TEMP1 now hold Y0/8 high and low byte respectively. Apply damping and flip speed vector.
        ; Take advantage of the fact that -(x*7/8) = (v >>> 3) - v
        SEC
        LDA     TEMP1
        SBC     VY0
        STA     VY0
        LDA     TEMP2
        SBC     VY0+1
        STA     VY0+1

        ; Handle horizontal bounce
HBOUNCE LDA     X0+2
        CMP     #$01        ; Right edge bounce
        BCC     LBOUNCE
        LDA     X0+1
        CMP     #82
        BCS     DOHBNC      ; Yes we are bouncing!
LBOUNCE LDA     X0+2        ; Handle left edge
        BNE     APPLYG
        LDA     X0+1
        CMP     #30
        BCS     APPLYG

        ; Calculate lost momentum in bounce. 1/8 of the momentum is lost in each bounce
        ; This can be expressed as:
        ; v * 7/8 = x - (v/8) = v - (v >> 3)
        .DB $FE
DOHBNC  LDA     VX0
        STA     TEMP1
        LDA     VX0+1
        STA     TEMP2
        CMP     #$80        ; Sign extend (Original MSB negative -> carry set)
        ROR     TEMP2       ; 1
        ROR     TEMP1
        CMP     #$80
        ROR     TEMP2       ; 2
        ROR     TEMP1
        CMP     #$80
        ROR     TEMP2       ; 3
        ROR     TEMP1

        ; TEMP2 and TEMP1 now hold Y0/8 high and low byte respectively. Apply damping and flip speed vector.
        ; Take advantage of the fact that -(x*7/8) = (v >>> 3) - v
        SEC
        LDA     TEMP1
        SBC     VX0
        STA     VX0
        LDA     TEMP2
        SBC     VX0+1
        STA     VX0+1
        .DB $FF

        ; Apply gravity to velocity vector
APPLYG  CLC
        LDA     VY0
        ADC     #GRAVITY
        STA     VY0
        LDA     VY0+1
        ADC     #$00        ; Handle carry
        STA     VY0+1

        ; Update position
        LDA     X0          ; X coord
        CLC
        ADC     VX0
        STA     X0
        LDA     X0+1
        ADC     VX0+1
        STA     X0+1
        STA     VIC
        LDA     X0+2
        BIT     VX0+1
        BPL     POS
        ADC     #$FF
        CLC
POS     ADC     #$00        ; Handle carry into third byte
        STA     X0+2
        STA     VIC+$10     ; TODO: Refactor for multiple sprites

        CLC
        LDA     Y0          ; Y coord
        ADC     VY0
        STA     Y0
        LDA     Y0+1
        ADC     VY0+1
        STA     Y0+1
        STA     VIC+1

        LDA     ASAVE
        LDX     XSAVE
        LDY     YSAVE
        DEC     VIC+$19     ; Acknowledge interrupt
        JMP     $EA31

; Temporary variables
ASAVE   .DB     0           ; Acc during IRQ
XSAVE   .DB     0           ; X during IRQ
YSAVE   .DB     0           ; Y during IRQ

TEMP1   .DB     0           ; General purpose junk variable
TEMP2   .DB     0           ; General purpose junk variable
        
X0      .DB     0, 160, 0
X1      .DB     0, 160, 0
X2      .DB     0, 160, 0
X3      .DB     0, 160, 0
X4      .DB     0, 160, 0
X5      .DB     0, 160, 0
X6      .DB     0, 160, 0
X7      .DB     0, 160, 0

Y0      .DW     265 * 200 / 2     ; 16 bit Y coordinates
Y1      .DW     265 * 200 / 2
Y2      .DW     265 * 200 / 2
Y3      .DW     265 * 200 / 2
Y4      .DW     265 * 200 / 2
Y5      .DW     265 * 200 / 2
Y6      .DW     265 * 200 / 2
Y7      .DW     265 * 200 / 2

VX0      .DW     $fc01     ; X portion of speed vectors
VX1      .DW     $0000
VX2      .DW     $0000
VX3      .DW     $0000
VX4      .DW     $0000
VX5      .DW     $0000
VX6      .DW     $0000
VX7      .DW     $0000

VY0      .DW     $0000     ; Y portion of speed vectors
VY1      .DW     $0000
VY2      .DW     $0000
VY3      .DW     $0000
VY4      .DW     $0000
VY5      .DW     $0000
VY6      .DW     $0000
VY7      .DW     $0000

        .ALIGN  64

SPRITE  .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA




