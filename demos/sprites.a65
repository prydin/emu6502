        .ORG    $2000

        ; Physics constants
GRAVITY .EQ     32      ; 1/8 pixels/frame^2
BOUNCE  .EQ     240     ; 15/16 of kinetic energy preserved in bounce

        ; Initial coordinates
XINITL  .EQ     0
XINITM  .EQ     160
XINITH  .EQ     0
YINITL  .EQ     0
YINITH  .EQ     265 * 200 / 2

        ; Zero page variables
VX      .EQ     $B2
VY      .EQ     $B4
XPOS    .EQ     $B6
YPOS    .EQ     $B9

VIC     .EQ     $D000
SPTRS   .EQ     $07f8

        ; Randomize velocities
        LDY     #$00
        LDX     #$00
RANDV   JSR     NEWVELO
        LDA     VX
        STA     VX0,Y
        LDA     VX+1
        STA     VX0+1,Y
        LDA     VY
        STA     VY0,Y
        LDA     VY+1
        STA     VY0+1,Y
        INX
        INX
        INX
        INY
        INY
        CPY     #$10
        BNE     RANDV

        ; Initialize sprites
        LDA     #((>SPRITE << 8) + <SPRITE) >> 6    ; Load address of sprite 1 data
        LDX     #$00
LOADSP  STA     SPTRS,X
        INX
        CPX     #$08
        BNE     LOADSP
        LDA     #100
        STA     VIC
        STA     VIC+$01

        LDA     #$FF
        STA     VIC+$15     ; Enable all sprites

        ; Initialize interrupts
        SEI                 ; Disable IRQ
        LDA     VIC+$25     ; Enable raster interrupts
        ORA     #$01
        STA     VIC+$25
        LDA     #$30
        STA     VIC+$12
        LDA     VIC+$1A     ; Enable raster IRQ
        ORA     #$01
        STA     VIC+$1A
        LDA     #<FRAME
        STA     $0314
        LDA     #>FRAME
        STA     $0315
        CLI                 ; Enable IRQ
        RTS

        ; Raster IRQ - New frame
FRAME   BIT     VIC+$19     ; Is it for us?
        BMI     DOIRQ
        JMP     $EA31       ; Not for us, give control back to kernal

DOIRQ   STA     ASAVE       ; Save registers
        STX     XSAVE
        STY     YSAVE

        LDY     #$00        ; Pointer for everything except X position (because it's 3 bytes)
        LDX     #$00        ; X-position pointer

NXTSPRT LDA     X0,X        ; Load temporary X position variable
        STA     XPOS
        LDA     X0+1,X
        STA     XPOS+1
        LDA     X0+2,X
        STA     XPOS+2
        LDA     Y0,Y        ; Load temporary Y position variable
        STA     YPOS
        LDA     Y0+1,Y
        STA     YPOS+1
        LDA     VX0,Y       ; Load temporary X velocity variable
        STA     VX
        LDA     VX0+1,Y
        STA     VX+1
        LDA     VY0,Y       ; Load temporary Y velocity variable
        STA     VY
        LDA     VY0+1,Y
        STA     VY+1

        ; Physics calculations
        ; Handle vertical bounce
        LDA     VY+1     ; Bounce on downward motion only
        AND     #$80
        BNE     HBOUNCE
        LDA     YPOS+1       ; Check if we've passed the lower bound
        CMP     #230
        BCC     HBOUNCE

        ; Calculate lost momentum in bounce. 1/8 of the momentum is lost in each bounce
        ; This can be expressed as:
        ; v * 7/8 = x - (v/8) = v - (v >> 3)
        LDA     VY
        STA     TEMP1
        LDA     VY+1
        STA     TEMP2
        CMP     #$80        ; Sign extend (Original MSB negative -> carry set)
        ROR     TEMP2       ; 1
        ROR     TEMP1
        CMP     #$80
        ROR     TEMP2       ; 2
        ROR     TEMP1
        CMP     #$80
        ROR     TEMP2       ; 3
        ROR     TEMP1

        ; TEMP2 and TEMP1 now hold Y0/8 high and low byte respectively. Apply damping and flip speed vector.
        ; Take advantage of the fact that -(x*7/8) = (v >>> 3) - v
        SEC
        LDA     TEMP1
        SBC     VY
        STA     VY
        LDA     TEMP2
        SBC     VY+1
        STA     VY+1

        ; Avoid strange effects by setting the LSB to zero if the MSB is zero after the bounce.
        ; This will make the object come to rest.
        BEQ     DONEWV
        CMP     #$FF
        BNE     HBOUNCE
DONEWV  JSR     NEWVELO
        LDA     #XINITL
        STA     XPOS
        LDA     #XINITM
        STA     XPOS+1
        LDA     #XINITH
        STA     XPOS+2
        LDA     #YINITL
        STA     YPOS
        LDA     #YINITH
        STA     YPOS+1

        ; Handle horizontal bounce
HBOUNCE LDA     XPOS+2
        CMP     #$01        ; Right edge bounce
        BCC     LBOUNCE
        LDA     XPOS+1
        CMP     #82
        BCS     DOHBNC      ; Yes we are bouncing!
LBOUNCE LDA     XPOS+2      ; Handle left edge
        BNE     APPLYG
        LDA     XPOS+1
        CMP     #30
        BCS     APPLYG

        ; Calculate lost momentum in bounce. 1/8 of the momentum is lost in each bounce
        ; This can be expressed as:
        ; v * 7/8 = x - (v/8) = v - (v >> 3)
DOHBNC  LDA     VX
        STA     TEMP1
        LDA     VX+1
        STA     TEMP2
        CMP     #$80        ; Sign extend (Original MSB negative -> carry set)
        ROR     TEMP2       ; 1
        ROR     TEMP1
        CMP     #$80
        ROR     TEMP2       ; 2
        ROR     TEMP1
        CMP     #$80
        ROR     TEMP2       ; 3
        ROR     TEMP1

        ; TEMP2 and TEMP1 now hold Y0/8 high and low byte respectively. Apply damping and flip speed vector.
        ; Take advantage of the fact that -(x*7/8) = (v >>> 3) - v
        SEC
        LDA     TEMP1
        SBC     VX
        STA     VX
        LDA     TEMP2
        SBC     VX+1
        STA     VX+1

        ; Apply gravity to velocity vector
APPLYG  CLC
        LDA     VY
        ADC     #GRAVITY
        STA     VY
        LDA     VY+1
        ADC     #$00        ; Handle carry
        STA     VY+1

        ; Update position
        LDA     XPOS          ; Add X-portion of speed vector to position
        CLC
        ADC     VX
        STA     XPOS
        LDA     XPOS+1
        ADC     VX+1
        STA     XPOS+1
        STA     VIC,Y
        LDA     XPOS+2
        BIT     VX+1        ; Sign extend into third byte
        BPL     POS
        ADC     #$FF
        CLC
POS     ADC     #$00        ; Handle carry into third byte
        STA     XPOS+2
        BEQ     CLEARHI     ; Setting or clearing high bit?
        LDA     HIMASK,Y    ; Setting it. Just OR it in
        ORA     VIC+$10
        STA     VIC+$10
        BNE     SETYPOS
CLEARHI LDA     HIMASK,Y    ; Clearing it. And with inverse
        EOR     #$FF
        AND     VIC+$10
        STA     VIC+$10

SETYPOS CLC
        LDA     YPOS         ; Y coord
        ADC     VY
        STA     YPOS
        LDA     YPOS+1
        ADC     VY+1
        STA     YPOS+1
        STA     VIC+1,Y

        ; Write back to non-temporary variables

        STA     Y0+1,Y        ; A should already hold [YPOS+1]
        LDA     XPOS
        STA     X0,X
        LDA     XPOS+1
        STA     X0+1,X
        LDA     XPOS+2
        STA     X0+2,X
        LDA     YPOS
        STA     Y0,Y
        LDA     VX
        STA     VX0,Y
        LDA     VX+1
        STA     VX0+1,Y
        LDA     VY
        STA     VY0,Y
        LDA     VY+1
        STA     VY0+1,Y

        INY                 ; Move to next sprite
        INY
        CPY     #$10        ; Handled all sprites?
        BEQ     END
        INX
        INX
        INX
        JMP     NXTSPRT

END     LDA     ASAVE
        LDX     XSAVE
        LDY     YSAVE
        DEC     VIC+$19     ; Acknowledge interrupt
        JMP     $EA31

        ; Subroutine to get an 8-bit random number
RND8    JSR     RAND
        LDA     SEED0
        EOR     SEED1
        EOR     SEED2
        EOR     SEED3
        RTS

        ; Get random number for high byte of velocities. We limit it to 3 and sign negate randomly
RNDHI   JSR     RND8
        LSR                 ; Put lowest bit into carry
        AND     #$03        ; Use only 2 lowest bits
        BCC     RNDPOS      ; Negate?
        EOR     #$FF        ; Ones complement
RNDPOS  ADC     #$00        ; Twos complement if carry is set. Does nothing otherwise.
        RTS

        ; Subroutine to calculate random velocity vectors
NEWVELO JSR     RND8
        STA     VX
        JSR     RNDHI
        STA     VX+1
        JSR     RND8
        STA     VY
        JSR     RNDHI
        STA     VY+1
        RTS

        .INCLUDE    demos/random.a65

; Temporary variables
ASAVE   .DB     0           ; Acc during IRQ
XSAVE   .DB     0           ; X during IRQ
YSAVE   .DB     0           ; Y during IRQ

TEMP1   .DB     0           ; General purpose junk variable
TEMP2   .DB     0           ; General purpose junk variable
        
X0      .DB     0, 160, 0
X1      .DB     0, 160, 0
X2      .DB     0, 160, 0
X3      .DB     0, 160, 0
X4      .DB     0, 160, 0
X5      .DB     0, 160, 0
X6      .DB     0, 160, 0
X7      .DB     0, 160, 0

Y0      .DW     265 * 200 / 2     ; 16 bit Y coordinates
Y1      .DW     265 * 200 / 2
Y2      .DW     265 * 200 / 2
Y3      .DW     265 * 200 / 2
Y4      .DW     265 * 200 / 2
Y5      .DW     265 * 200 / 2
Y6      .DW     265 * 200 / 2
Y7      .DW     265 * 200 / 2

VX0     .DW     $fc01     ; X portion of speed vectors
VX1     .DW     $0100
VX2     .DW     $0000
VX3     .DW     $0000
VX4     .DW     $0000
VX5     .DW     $0000
VX6     .DW     $0000
VX7     .DW     $0000

VY0     .DW     $0000     ; Y portion of speed vectors
VY1     .DW     $0000
VY2     .DW     $0000
VY3     .DW     $0000
VY4     .DW     $0000
VY5     .DW     $0000
VY6     .DW     $0000
VY7     .DW     $0000

HIMASK  .DB      $01, $01, $02, $02, $04, $04, $08, $08, $10, $10, $20, $20, $40, $40, $80, $80

        .ALIGN  64

SPRITE  .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA
        .DB     $AA, $AA, $AA




